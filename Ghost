Ghost snapshots
A ghost is a networked object that the server simulates. During every frame, the server sends a snapshot of the current state of all ghosts to the client. The client presents them, but cannot directly control or affect them because the server owns them.

The ghost snapshot system synchronizes entities which exist on the server to all clients. To make it perform properly, the server processes per ECS chunk rather than per entity. On the receiving side the processing is done per entity. This is because it is not possible to process per chunk on both sides, and the server has more connections than clients.

Why use Ghosts? Ghosts vs. RPCs
Ghost Snapshot Synchronization ("Eventual Consistency") Use-Cases
To replicate spatially local, ephemeral, and relevant per-entity data.
To enable client prediction of ghost entities, which is the most effective latency-hiding multiplayer technique.
RPC Use-Cases
High-level game flow events. Example: Making every client do a certain thing, like load a specific level.
Sending one-shot, non-predicted commands from the client to the server. Example: Join this Squad. Send a chat message. Unmute this player. Request to exit this realm. etc.
Key Differences:
RPCs are "one-shot" events, and are thus not automatically persisted. Example: If you send an RPC when a treasure chest is opened, if a player disconnects and reconnects, the chest will appear closed.
Ghost data persists for the lifetime of its Ghost entity (and the lifetime of the ghost entity is itself replicated). Therefore, long-lived user-interactable entities should have their persistent state stored in Ghost components. Example: A chests FSM can be stored as an enum on a Component. If a player opens the chest, disconnects, then reconnects, they will re-receive the chest, as well as its open state.
RPCs are sent as reliable packets, while ghosts snapshots are unreliable (with "eventual consistency").
RPC data is sent and received as it is, while ghost data goes through optimizations like diff and delta-compression, and can go through value smoothing when received.
RPCs are not tied to any particular tick, or other snapshot timing data. They are simply processed on the frame that they are received.
Ghost snapshot data can work with interpolation and prediction (with snapshot history), and thus history, rollback, and resimulation.
Ghost snapshot data can be bandwidth optimized via relevancy and importance. RPCs are either broadcast, or sent to a single client.
Authoring Ghosts
Ghost can be authored in the editor by creating a Prefab with a GhostAuthoringComponent.

Ghost Authoring Component

The GhostAuthoringComponent has a small editor which you can use to configure how Netcode synchronizes the Prefab.
You must set the Name, Importance, Supported Ghost Mode, Default Ghost Mode and Optimization Mode property on each ghost.
Netcode for Entities uses the Importance property to control which entities are sent when there is not enough bandwidth to send all. A higher value makes it more likely that the ghost will be sent.

You can select from three different Supported Ghost Mode types:

All - this ghost supports both being interpolated and predicted.
Interpolated - this ghost only supports being interpolated, it cannot be spawned as a predicted ghost.
Predicted - this ghost only supports being predicted, it cannot be spawned as a interpolated ghost.
You can select from three different Default Ghost Mode types:

Interpolated - all ghosts Unity receives from the server are treated as interpolated.
Predicted - all ghosts Unity receives from the server are treated as predicted.
Owner predicted - the ghost is predicted for the client that owns it, and interpolated for all other clients. When you select this property, you must also add a GhostOwner and set its NetworkId field in your code. Unity compares this field to each clients’ network ID to find the correct owner.
You can select from two different Optimization Mode types:

Dynamic - the ghost will be optimized for having small snapshot size both when changing and when not changing.
Static - the ghost will not be optimized for having small snapshot size when changing, but it will not be sent at all when it is not changing.
Replicating Components and Buffers
Netcode for Entities uses C# attributes to configure which components and fields are synchronized as part of a ghost. There are three fundamental attributes you can use:

NetCode Attribute	Usage
GhostFieldAttribute	The GhostFieldAttribute should be used to mark which component (or buffer) fields should be serialised.
The attribute can be added to struct fields and properties.
Once a component has at least one field marked with [GhostField], it becomes replicated, and will be transmitted as part of the ghost data.
GhostEnabledBitAttribute	Similarly, the GhostEnabledBitAttribute should be used on an IEnableableComponent struct definition, to denote that the enabled bit for this component should be serialized.
Once a component is flagged with [GhostEnabledBit], its enabled-bit will be replicated, and thus transmitted as part of the ghost data.
GhostComponentAttribute	The GhostComponentAttribute should be used on a ComponentType struct definition to:
- Declare for which version of the Prefab the component should be present.
- Declare if the component should be serialised also for child entities.
- Declare to which subset of clients a component should be replicated.
Authoring component serialization
To signal the Netcode for Entities that a component should be serialised, you need to add a [GhostField] attribute to the values you want to send.

public struct MySerialisedComponent : IComponentData
{
    [GhostField]public int MyIntField;
    [GhostField(Quantization=1000)]public float MyFloatField;
    [GhostField(Quantization=1000, Smoothing=SmoothingAction.Interpolate)]public float2 Position;
    public float2 NonSerialisedField;
    ...
}
For a component to support serialization, the following conditions must be met:

The component itself must be declared as public.
Only public members are considered. Adding a [GhostField] to a private member has no effect.
The GhostField can specify Quantization for floating point numbers (and other supported types, see Ghost Type Templates). The floating point number will be multiplied by this Quantization value, and converted to an integer, in order to save bandwidth. Specifying a Quantization is mandatory for floating point numbers. To send a floating point number unquantized; you have to explicitly specify [GhostField(Quantization=0)].
The GhostField Composite flag controls how the delta compression computes the change fields bitmask for non primitive fields (i.e. structs). When set to true, the delta compression will generate only 1 bit to indicate if the entire struct contains any changes. If Composite is false, each field will have its own change-bit. Thus, use Composite=true if all fields are typically modified together (example: GUID).
The GhostField SendData flag (which defaults to true) can be used to instruct code-generation to not include this field in the serialization data. This is particularly useful for non primitive members (like structs), which will have all fields serialized by default.
The GhostField also has a Smoothing property, which controls how the field will be updated, when the ghost is in GhostMode.Interpolated. I.e. When a given client is not predicting said ghost. Possible values are:
SmoothingAction.Clamp - Every time a snapshot is received, jump (i.e. clamp) the client value to the latest snapshot value.
SmoothingAction.Interpolate - Every frame, interpolate the field between the last two snapshot values. If no data is available for the next tick, clamp to the latest value.
SmoothingAction.InterpolateAndExtrapolate - Every frame, interpolate the field between the last two snapshot values. If no data is available for the next tick, the next value is linearly extrapolated using the previous two snapshot values. Extrapolation is limited (i.e. clamped) via ClientTickRate.MaxExtrapolationTimeSimTicks.
GhostField MaxSmoothingDistance allows you to disable interpolation when the values change more than the specified limit between two snapshots. This is useful for dealing with teleportation, for example.
Finally the GhostField has a SubType property which can be set to an integer value to use special serialization rules supplied for that specific field.
![NOTE] Speaking of teleportation: To support short range teleportation, you'd need some other replicated bit to distinguish a teleport from a move (lerp).

Authoring dynamic buffer serialization
Dynamic buffers serialization is natively supported. Unlike components, to replicate a buffer, all public fields must be marked with at [GhostField] attribute.

![NOTE] This restriction has been added to guarantee that: In the case where an element is added to the buffer, when it is replicated to the client, all fields on said element will have meaningful values. This restriction may be removed in the future (e.g. by instead, defaulting this undefined behaviour to default(T)).

public struct SerialisedBuffer : IBufferElementData
{
    [GhostField]public int Field0;
    [GhostField(Quantization=1000)]public float Field1;
    [GhostField(Quantization=1000)]public float2 Position;
    public float2 NonSerialisedField; // This is an explicit error!
    private float2 NonSerialisedField; // We allow this. Ensure you set this on the client, before reading from it.
    [GhostField(SendData=false)]public int NotSentAndUninitialised; // We allow this. Ensure you set this on the client, before reading from it.
    ...
}
Furthermore, in line with the IComponentData:

The buffer must be declared as public.
Only public members are considered. Adding a [GhostField] to a private member has no effect.
By using the GhostField.SendData you can instrument the serialisation code to skip certain field. In such a case:
the value of the fields that aren't replicated are never altered
for new buffer elements, their content is not set to default and the content is undefined (can be any value).
Dynamic buffers fields don't support SmoothingActions. Thus, the GhostFieldAttribute.Smoothing and GhostFieldAttribute.MaxSmoothingDistance properties will be ignored when used on buffers.

ICommandData and IInputComponentData serialization
ICommandData, being a subclass of IBufferElementData, can also be serialized from the server to clients. As such, the same rules for buffers apply: if the command buffer must be serialized, then all fields must be annotated.

    [GhostComponent()]
    public struct MyCommand : ICommandData
    {
        [GhostField] public NetworkTick Tick {get; set;}
        [GhostField] public int Value;
    }
The same applies when using automated input synchronization with IInputComponentData.

    public struct MyCommand : IInputComponentData
    {
        [GhostField] public int Value;
    }
The command data serialization is particularly useful for implementing RemotePlayerPrediction.

Ghost Field Inheritance
If a [GhostField] is specified for a non primitive field type, the attribute (and some of its properties) are automatically inherited by all the sub-fields which do not themselves implement a [GhostField] attribute. For example:


public struct Vector2
{
    public float x;
    [GhostField(Quantization=100)] public float y;
}

public struct MyComponent : IComponentData
{
    //Value.x will inherit the quantization value specified by the parent definition (1000).
    //Value.y will maintain its original quantization value (100).
    [GhostField(Quantized=1000)] public Vector2 Value;
}
The following properties are not inherited:

SubType - The subtype is always reset to the default
Using the GhostComponentAttribute
The GhostComponentAttribue does not indicate or signal that a component is replicated (that's what the other two attributes are for). Instead, it should be used to instruct the runtime how to handle the component when it comes to:

SendDataForChildEntity denotes whether or not to replicate this component when it is attached to a child of a ghost entity. Replicating child of ghost entities is significantly slower than replicating those ghost root entities. Thus, we default to false. This flag also applies to the [GhostEnabledBit].
PrefabType allows you to remove the component from the specific version of the ghost prefab. Ghost prefabs have three versions: Interpolated Client (IC), Predicted Client (PC), and Server (S). Example: Removing rendering related components from the server world's version of this ghost.
GhostSendType denotes whether or not the component should be sent when the ghost is GhostMode.Predicted vs GhostMode.Interpolated. Example: Only sending PhysicsVelocity when you're actually predicting the physics of a ghost.
SendToOwnerType denotes whether or not to replicate this data when the ghost is owned, vs not owned, vs either. Example: Replicating input commands only to other players (as you already know your own).
[GhostComponent(PrefabType=GhostPrefabType.All, SendTypeOptimization=GhostSendType.OnlyInterpolatedClients, SendDataForChildEntity=false)]
public struct MyComponent : IComponentData
{  
    [GhostField(Quantized=1000)] public float3 Value;
}
PrefabType Details
To change which versions of a Ghost Prefab a component is available on, use PrefabType in a GhostComponentAttribute on the component. PrefabType can be on of the these types:

InterpolatedClient - the component is only available on clients, and only when the ghost is interpolated.
PredictedClient - the component is only available on clients, and only when the ghost is predicted.
Client - the component is only available on clients, regardless of the GhostMode (e.g. either predicted or interpolated).
Server - the component is only available on the server.
AllPredicted - the component is only available on the server, and on clients, only when the ghost is predicted.
All - the component is available on the server and all clients.
For example, if you add [GhostComponent(PrefabType=GhostPrefabType.Client)] to RenderMesh, the ghost won’t have a RenderMesh when it is instantiated on the server world, but it will have it when instantiated on the client world.

NOTE
Runtime Prediction Switching therefore has the potential to add and remove components on a ghost, live.

SendTypeOptimization Details
A component can set SendTypeOptimization in the GhostComponentAttribute to control which clients the component is sent to, whenever a ghost type is known at compile time. The available modes are:

None - the component is never sent to any clients. Netcode will not modify the component on the clients which do not receive it.
Interpolated - the component is only sent to clients which are interpolating the ghost.
Predicted - the component is only sent to clients which are predicting the ghost.
All - the component is sent to all clients.
A component can also set SendDataForChildEntity to true in order to change the default (of not serializing children), allowing this component to be serialized when on a child.

A component can also set SendToOwner in the GhostComponentAttribute to specify if the component should be sent to client who owns the entity. The available values are:

SendToOwner - the component is only sent to the client who own the ghost
SendToNonOwner - the component is sent to all clients except the one who owns the ghost
All - the component is sent to all clients.
![NOTE] By setting either the SendTypeOptimisation and/or SendToOwner (to specify to which types of client(s) the component should be replicated to), will not affect the presence of the component on the prefab, nor modify the component on the clients which did not receive it.

How to add serialization support for custom Types
The types you can serialize via GhostFieldAttribute are specified via templates. You can see the default supported types [here](ghost-types-templates.md#Supported Types)

In addition to the default out-of-the-box types you can also:

add your own templates for new types.
provide a custom serialization templates for a types and target by using the SubTypes property of the GhostFieldAttribute.
Please check how to [use and write templates](ghost-types-templates.md#Defining additional templates) for more information on the topic.

![NOTE] Writing templates is non-trivial. If it is possible to replicate the type simply by adding GhostFields, it's often easier to just do so. If you do not have access to a type, create a Variant instead (see section below).

Ghost Component Variants
The GhostComponentVariationAttribute is special attribute tha can be used to declare at compile time a "replication schema" for a type, without the need to markup the fields in the original type, or the original type itself.

![NOTE]This new declared type act as proxy from a code-generation perspective. Instead of using the original type, the code-generation system use the declared "variant" to generate a specific version of the serialization code. ![NOTE] Ghost components variants for IBufferElementData are not fully supported.

The GhostComponentVariationAttribute has some specific use-cases in mind:

Variants allow user-code (you) to declare serialization rules for a component that you don't have direct write access too (i.e. components in a package or external assembly). Example: Making Unity.Entities.LocalTransform replicated.
Generate multiple serialization strategies for a single type (i.e: provide multiple ways to replicate a single type, allowing individual ghosts to select their version). Example: Replicate only the Yaw value of Unity.Entities.LocalRotation, or the full quaternion.
Strip components (i.e: RenderMesh) from certain prefab types (e.g. from the Server) by overriding or adding a GhostComponentAttribute to the type, without changing the original declaration.
    [GhostComponentVariation(typeof(LocalTransform), "Transform - 2D")]
    [GhostComponent(PrefabType=GhostPrefabType.All, SendTypeOptimization=GhostSendType.AllClients)]
    public struct PositionRotation2d
    {
        [GhostField(Quantization=1000, Smoothing=SmoothingAction.InterpolateAndExtrapolate, SubType=GhostFieldSubType.Translation2D)]
        public float3 Position;
        [GhostField(Quantization=1000, Smoothing=SmoothingAction.InterpolateAndExtrapolate, SubType=GhostFieldSubType.Rotation2D)]
        public quaternion Rotation;
    }
In the example above, the PositionRotation2d Variation will generate serialization code for LocalTransform, using the properties and the attribute present in the variant declaration.

The attribute constructor takes a few arguments:

The Type type of the ComponentType you want to specify the variant for (ex: LocalTransform).
The user-friendly string variantName, which will allow you to better interpret GhostAuthoringInspectionComponent UI.
Then, for each field in the original struct (in this case, LocalTransform) that you wish to replicate, you should add a GhostField attribute like you usually do, and define the field identically to that of the base struct.

~[NOTE] Only members that are present in the component type are allowed. Validation occurs at compile time, and exceptions are thrown in case this rule is not respected.

An optional GhostComponentAttribute attribute can be added to the variant to further specify the component serialization properties.

It is possible to declare multiple serialization variant for a component (example: 2D and 3D variations for LocalRotation).

NOTE
If you only define only one Variant for a ComponentType, it becomes the default serialization strategy for that type automatically.

Preventing a component from supporting Variations
There are cases where you'd like to prevent a component from having its serialization modified via Variants. Example: From the NetCode package itself, we must always replicate the GhostComponent for netcode systems to work properly, so we don't let user-code (you) modify serialization rules for it).

Thus, to prevent a component from supporting variation, use the DontSupportPrefabOverridesAttribute attribute. An error will be reported at compile time, if a GhostComponentVariation is defined for that type.

Specify which variant to use on a Ghost Prefab
Using the GhostAuthoringInspectionComponent MonoBehaviour in conjunction with the GhostAuthoringComponent MonoBehaviour, it is possible to select what serialization variants to use on a per-prefab basis. You can choose a Variant for each individual component (including the ability to set the special-case variant: DontSerializeVariant).

Ghost Authoring Variants

All variants for that specific component type present in the project will be show in a dropbox selection.
To modify how children of Ghost prefabs are replicated, add a GhostAuthoringInspectionComponent to each individual child.

NOTE
The GhostAuthoringInspectionComponent is also an incredibly valuable debugging tool. Add it to a Ghost Prefab (or one of its children) to view all replicated types on said Ghost, and to diagnose why a specific type is not replicating in the way you'd expect.

Assigning a default variant to use for a Type
In cases where multiple variants are present for a type, Netcode may be unable to infer which Variant should be used. If the "Default Serializer" for the Type is replicated, it'll default to it. If not, it is considered a conflict, and you'll get runtime exceptions when creating any netcode world (including Baking worlds). We use a built-in, deterministic, fallback method to guess which variant you likely want, but, in general, it is the users responsibility to indicate what Variant should be the default here.

To setup which variant to use as the default for a given type, you need to create a system that inherits from DefaultVariantSystemBase class, and implements the RegisterDefaultVariants method.

using System.Collections.Generic;
using Unity.Entities;
using Unity.Transforms;

namespace Unity.NetCode.Samples
{
    sealed class DefaultVariantSystem : DefaultVariantSystemBase
    {
        protected override void RegisterDefaultVariants(Dictionary<ComponentType, Rule> defaultVariants)
        {
            defaultVariants.Add(typeof(LocalTransform), Rule.OnlyParents(typeof(TransformDefaultVariant)));
        }
    }
}
This example code would make sure the default LocalTransform variant to us as default is the TransformDefaultVariant. For more information, please refer to the DefaultVariantSystemBase documentation.

NOTE
This is the recommended approach to setup the default Variant for a Ghost "project-wide". Prefer DefaultVariantSystemBase over direct Variant manipulation (via the GhostAuthoringInspectionComponent overrides).

Special Variant Types
Special Built-in Variant	Details
ClientOnlyVariant	Use this to specify that a given ComponentType should only appear on client worlds.
ServerOnlyVariant	The inverse.
DontSerializeVariant	Use this to disable serialization of a Type entirely. I.e. Use it to ignore replication attributes ([GhostField] and [GhostEnabledBit]).
using System.Collections.Generic;
using Unity.Entities;
using Unity.Transforms;

namespace Unity.NetCode.Samples
{
    sealed class DefaultVariantSystem : DefaultVariantSystemBase
    {
        protected override void RegisterDefaultVariants(Dictionary<ComponentType, Rule> defaultVariants)
        {
            defaultVariants.Add(typeof(SomeClientOnlyThing), Rule.ForAll(typeof(ClientOnlyVariant)));
            defaultVariants.Add(typeof(SomeServerOnlyThing), Rule.ForAll(typeof(ServerOnlyVariant)));
            defaultVariants.Add(typeof(NoNeedToSyncThis), Rule.ForAll(typeof(DontSerializeVariant)));
        }
    }
}
You can also manually pick the DontSerializeVariant in the ghost component on ghost prefabs (via the GhostAuthoringInspectionComponent).

Assign variants and override GhostComponentAttribute settings on ghost prefabs
It is possible to override the following meta-data on per-prefab basis, by using the GhostAuthoringInspectionComponent editor.

Ghost Authoring Component

The GhostAuthoringInspectionComponent should be added to the GameObject you would like to customise. Once added, the editor will show which components present in the runtime entity are replicated.
The editor allow you to: change the following properties:

Change the PrefabType in which the component should be present/replicated.
Change the SendToOptimization for this component (if applicable)
Assign the serialization Variant to use for that component.
It is possible to prevent a component from supporting per-prefab overrides by using the DontSupportPrefabOverrides attribute.
When present, the component can't be customized in the inspector, nor can a programmer add custom or default variants for this type (as that will trigger errors during ghost validation).

For example: The Netcode for Entities package requires the GhostOwner to be added to all ghost types, sent for all ghost types, and serialized using the default variant. Thus, we add the [DontSupportPrefabOverride] attribute to it.

![NOTE] Components on child entities are not serialised by default, thus by default when you look to GhostAuthoringInspectionComponent on a child GameObject you will see that the selected variant for the type is the DontSerializeVariant.

<img src="images/dontserialize-variant.png" alt="DontSerializeVariant" width=600/>

Snapshot visualization tool
To understand what is being put on the wire in the Netcode, you can use the snapshot visualization tool, NetDbg tool.

net debug tool

To open the tool, go to menu: Multiplayer > Open NetDbg, and the tool opens in a browser window. It displays a vertical bar for each received snapshot, with a breakdown of the snapshot’s ghost types, size etc.

To see more detailed information about the snapshot, click on one of the bars.

NOTE
This tool is a prototype. In future versions of the package, it will integrate with the Unity Profiler so you can easily correlate network traffic with memory usage and CPU performance

Spawning Ghost Entities
A ghost is spawned simply by instantiating it on the server, all ghosts on the server are replicated to all clients. Ghosts which are inside subscenes are a special case and handled as pre-spawned ghosts. If their subscene state has not been changed when a client connects he does not need any snapshot data updates for pre-spawned ghosts. On clients ghosts can be predict spawned and later matched with a server spawn as soon as a snapshot update is applied for it. It is not valid to instantiate another type of ghosts on clients as the server is authoritative and is the true authority of what ghosts exists in the world.

Ghosts Entities on the client
Netcode for Entities does not have and nor does requires a specific spawn message. When the client receives an unknown/new ghost id, it counts as an implicit spawn.

When the client receives a new ghost, the ghost is first "classified" by a set of classification systems to determine its spawning type. Once the spawn type has been set, the GhostSpawnSystem will take care of instantiating the new entity.

Different type of spawning
Spawning is split into three main types as follows:

Delayed or interpolated spawning: Because the client interpolates snapshot data, non predicted ghosts cannot be immediately spawned. Otherwise, the object would appear and then not get any more updates until we receive new data from server and we can start interpolating it.
This spawn delay is governed by the Interpolation Delay. The interpolated ghosts spawn when the Interpolated Tick is greater or equals their spawn tick. See time synchronization for more information about interpolation delay and interpolation tick.
Predicted spawning for the client predicted player object: The object is predicted so the input handling applies immediately. Therefore, it doesn't need to be delay spawned. When the snapshot data for this object arrives, the update system applies the data directly to the object and then plays back the local inputs which have happened since that time, and corrects mistakes in the prediction.
Predicted spawning for player spawned objects: This usually applies to objects that the player spawns, like in-game bullets or rockets that the player fires.
![NOTE] Ghost entities can be spawned only if the ghost prefabs are loaded/present in the world. Server and client should agree upon the prefabs they have and the server will only report to the client ghosts for which the client has the prefab.

Implement Predicted Spawning for player spawned objects
The spawn code needs to run on the client, in the client prediction system.
Any prefab ghost entity the client instantiates has the PredictedGhostSpawnRequest added to it and is therefore treated as a predict spawned entity by default.

When the first snapshot update for this entity arrives, we detect that the received update is for an entity already spawned by client and from that time on, all the updates will be applied to it.

In the prediction system code the NetworkTime.IsFirstTimeFullyPredictingTick value needs to be checked in order to prevent the spawned object from being spawned multiple times as data is rolled back and redeployed as part of the prediction loop.

public void OnUpdate()
{
    // Other input like movement handled here or in another system...

    var networkTime = SystemAPI.GetSingleton<NetworkTime>();
    if (!networkTime.IsFirstTimeFullyPredictingTick)
        return;
    // Handle the input for instantiating a bullet for example here
    // ...
}
These client spawned objects are automatically handled by the GhostSpawnClassificationSystem system, that matches the new received ghosts with any of the client predicted spawned ones, based by their types and spawning tick (should be within 5 ticks).

You can implement a custom classification with more advanced logic than this to override the default behaviour.

Adding your own classification system
To override the default client classification you can create your own classification system. The system is required to:

Update in the GhostSimulationSystemGroup
Run after the GhostSpawnClassificationSystem
The classification system can inspect the ghosts that need to be spawned by retrieving the GhostSpawnBuffer buffer on the singleton GhostSpawnQueueComponent entity and change their SpawnType.

Each entry in that list should be compared to the entries in the PredictedGhostSpawn buffer on the singleton with a PredictedGhostSpawnList component. If the two entries have the same type and "match", the classification system should set the PredictedSpawnEntity property in the GhostSpawnBuffer element and remove the entry from PredictedGhostSpawn buffer.

public void Execute(DynamicBuffer<GhostSpawnBuffer> ghosts, DynamicBuffer<SnapshotDataBuffer> data)
{
    var predictedSpawnList = PredictedSpawnListLookup[spawnListEntity];
    for (int i = 0; i < ghosts.Length; ++i)
    {
        var newGhostSpawn = ghosts[i];
        if (newGhostSpawn.SpawnType != GhostSpawnBuffer.Type.Predicted || newGhostSpawn.HasClassifiedPredictedSpawn || newGhostSpawn.PredictedSpawnEntity != Entity.Null)
            continue;

        // Mark all the spawns of this type as classified even if not our own predicted spawns
        // otherwise spawns from other players might be picked up by the default classification system when
        // it runs.
        if (newGhostSpawn.GhostType == ghostType)
            newGhostSpawn.HasClassifiedPredictedSpawn = true;

        // Find new ghost spawns (from ghost snapshot) which match the predict spawned ghost type handled by
        // this classification system. You can use the SnapshotDataBufferLookup to inspect components in the 
        // received snapshot in your matching function
        for (int j = 0; j < predictedSpawnList.Length; ++j)
        {
            if (newGhostSpawn.GhostType != predictedSpawnList[j].ghostType)
                continue;

            if (YOUR_FUZZY_MATCH(newGhostSpawn, predictedSpawnList[j]))
            {
                newGhostSpawn.PredictedSpawnEntity = predictedSpawnList[j].entity;
                predictedSpawnList[j] = predictedSpawnList[predictedSpawnList.Length - 1];
                predictedSpawnList.RemoveAt(predictedSpawnList.Length - 1);
                break;
            }
        }
        ghosts[i] = newGhostSpawn;
    }
}
Inside your classification system you can use the SnapshotDataBufferLookup to:

Check for component presence in the ghost archetype
Retrieve from the snapshot data associated with the new ghost any replicated component type.
Pre-spawned ghosts
A ghost instance (an instance of a ghost prefab) can be placed in a sub-scene in the Unity editor so that it will be treated just like a normal spawned ghost when the scene is loaded.

To create a prespawned ghost from a normal scene you can do the following:

Right click on the Hierarchy in the inspector and click New Sub Scene.
Drag an instance of a ghost prefab into the newly created subscene.
prespawn ghost

There are some restrictions for pre-spawned ghosts:

It must be an instance of a ghost prefab.
It must be place in a sub-scene.
Pre-spawned ghosts in the same scene cannot have the exact same position and rotation.
Pre-spawned ghosts MUST be put always put on the main scene section (section 0).
The ghost authoring component on the pre-spawned ghost cannot be configured differently than the ghost prefab source (that data is handled on a ghost type basis).
How pre-spawned ghosts works
At baking time, each sub-scene assign a PrespawnId to the ghosts it contains in a deterministic manner. The ids are assigned by sorting the ghost by the mean of a deterministic hash that takes in account the Rotation and Translation of the entity.

For each sub-scene then, a combined hash that contains:

the SceneGUID
all the ghosts calculated hashes
is extracted and used to :

group the pre-spawned ghost on a per-sub-scene basis by assigning a SubSceneGhostComponentHash shared component to all the ghosts in the scene
add to the SceneSection a SubSceneWithPrespawnGhosts component, that will be used by the runtime to handle sub-scene with pre-spawned ghosts.
At runtime, when a sub-scene has been loaded, is processed by both client and server:

For each pre-spawned ghost, a Prespawn Baseline is extracted and used to delta compress the ghost component when it is first sent (bandwidth optimisation)
The server assign to sub-scene a unique Ghost Id Range that is used to assign distinct ghost-id to the pre-spawned ghosts based on their PrespawnId.
The server will replicated to the client by using an internal ghost entity, the assigned id ranges for each sub-scene (identified by the hash assigned to the SubSceneWithPrespawnGhosts component)
Once the client has loaded the sub-scene and received the ghost range, it will then:
Assign to the pre-spawned ghosts the server authoritative ids
Report to the server it is ready to stream the pre-spawned ghosts (via rpc)
This has to be done after all sub-scene have finished loading and the connection (at least one for the server) has bee set as in game (when the NetworkStreamInGame component has been added to the network connection).

![NOTE] If prespawned ghosts are moved before going in game or in general before the baseline is calculated properly, data may be not replicated correctly (the snapshot delta compression will fail). Both server and client calculate a CRC of the baseline and this hash is validated when clients connect. A mismatch will cause a disconnection. This also the reason why the ghost are Disabled.

For both client and server, when a sub-scene has been processed (ghost id assigned) a PrespawnsSceneInitialized component is added to the main SceneSection.
The client automatically track when sub-scene with pre-spawned ghosts are loaded/unloaded and report to the server to stop streaming pre-spawned ghosts associated with them.

Dynamic loading sub-scene with pre-spawned ghosts.
It is possible to load at runtime a sub-scene with pre-spawned ghosts while you are already in-game. The pre-spawned ghosts will be automatically handled and synchronised. It also possible to unload sub-scenes that contains pre-spawned ghosts on demand. Netcode for Entities will handle that automatically, and the server will stop reporting the pre-spawned ghosts for sections the client has unloaded.

![NOTE] Pre-spawned ghost when baked become Disabled (the Disable tag is added to the entity at baking time). The entity is re-enabled after the scene is loaded and the serialisation baseline has been calculated.

You can get more information about the pre-spawned ghost synchronization flow, by checkin the:

ClientPopulatePrespawnedGhostsSystem
ServerPopulatePrespawnedGhostsSystem
ClientTrackLoadedPrespawnSections

Command stream
The client continuously sends a command stream to the server when the NetworkStreamConnection is tagged to be "in-game". This stream includes all inputs, and acknowledgements of the last received snapshot. Thus, the connection will be kept alive, even if the client does not have controlled entities, and does not generate any inputs that need to be transmitted to the server. The command packet is still sent at a regular interval (every full simulated tick), to automatically acknowledge received snapshots, and to report other important information to the server.

Creating inputs (i.e. commands)
To create a new input type, create a struct that implements the ICommandData interface. To implement that interface you need to provide a property for accessing the Tick.

The serialization and registration code for the ICommandData will be generated automatically, but it is also possible to disable that and write the serialization manually.

The ICommandData buffer can be added to the entity controlled by the player either at baking time (using an authoring component) or at runtime.
In the latter, make sure the dynamic buffer is present on both server and client.

Handling input on the client
The client is only responsible for polling the input source and add ICommand to buffer for the entities who it control.
The queued commands are then automatically sent at regular interval by CommandSendPacketSystem.

The systems responsible for writing to the command buffers must all run inside the GhostInputSystemGroup.

ICommandData serialization and payload limit
When using ICommand, the Netcode for Entities package automatically generated the command serialization code for you.
Commands serialization take place in the CommandSendSystemGroup. Each individual command is serialized and enqueued into the OutgoingCommandDataStreamBuffer (present on the network connection) by its own code-generated system.
The CommandSendPacketSystem is then responsible to flush the outgoing buffer at SimulationTickRate interval.

In order to fight packet losses, along with with last input, we also include as a form of redundancy the last 3 input. Each redundant command is delta compressed against the command for the current tick. The final serialized data looks something like:

| Tick, Command | CommandDelta(Tick-1, Tick) | CommandDelta(Tick-2, Tick) | CommandDelta(Tick-3, Tick)|
The package enforce a size limit of 1024 bytes to the command payload. The check is performed when the command is serialise into the outgoing buffer and an error will be reported to the application if the encoded payload that does not respect the constraint.

Receiving commands on the server
ICommandData are automatically received by the server by the NetworkStreamReceiveSystem and added to the IncomingCommandDataStreamBuffer buffer. The CommandReceiveSystem is then responsible to dispatch the command data to the target entity (which the command belong to).

NOTE
The server must only receive commands from the clients. It should never overwrite or change the input received by the client.

Automatic handling of commands. The AutoCommandTarget component.
If you add your ICommandData component to a ghost (for which the following options has been enabled in the `GhostAuthoring):

Has Owner set
Support Auto Command Target
enable-autocommand

the commands for that ghost will automatically be sent to the server. The following rules apply:

the ghost must be owned by your client (requiring the server to set the GhostOwner to your NetworkId.Value),
the ghost is Predicted or OwnerPredicted (i.e. you cannot use an ICommandData to control interpolated ghosts),
the AutoCommandTarget.Enabled flag is set to true.
If you are not using Auto Command Target, your game code must set the CommandTarget on the connection entity to reference the entity that the ICommandData component has been attached to.
You can have multiple ICommandData in your game, and Netcode for Entities will only send the ICommandData for the entity that CommandTarget points to.

When you need to access the inputs from the buffer, you can use an extension method for DynamicBuffer<ICommandData> called GetDataAtTick which gets the matching tick for a specific frame. You can also use the AddCommandData utility method (which adds more commands to the ring-buffer for you).

NOTE
When you update the state of your simulation inside the prediction loop, you must rely only on the commands present in the ICommandData buffer (for a given input type). Polling input directly, by using UnityEngine.Input or other similar method, or relying on input information not present in the struct implementing the ICommandData interface may cause client mis-prediction.

Checking which ghost entities are owned by the player, on the client.
NOTE
It is required you use (and implement) the GhostOwner functionality, for commands to work properly. For example: By checking the 'Has Owner' checkbox in the GhostAuthoringComponent.

On the client, it is very common to want to lookup (i.e. query for) entities that are owned by the local player. This is problematic, as multiple ghosts may have the same CommandBuffer as your "locally owned" ghost (e.g. when using Remove Player Prediction, every other "player" ghost will have this buffer), and your input systems (that populate the input command buffer) may accidentally clobber other players buffers.

There are two ways to handle this properly:

Use the new GhostOwnerIsLocal component (PREFERRED)
All ghosts have a special enableable component, GhostOwnerIsLocal that you can now use to filter out ghosts not owned by "you".

For example:

Entities
    .WithAll<GhostOwnerIsLocal>()
    .ForEach((ref MyComponent myComponent)=>
    {
        // your logic here will be applied only to the entities owned by the local player.    
    }).Run();
Use the GhostOwner
You can filter the entities manually by checking that the GhostOwner.NetworkId of the entity equals the NetworkId of the player.

var localPlayerId = GetSingleton<NetworkId>().Value;
Entities
    .ForEach((ref MyComponent myComponent, in GhostOwner owner)=>
    {
        if(owner.NetworkId == localPlayerId)
        {
            // your logic here will be applied only to the entities owned by the local player.
        }                
    }).Run();
Automatic command input setup using IInputComponentData
It's possible to have most of the things mentioned above for command data usage set up automatically for you given an input component data struct you have set up. You need to inherit the IInputComponentData interface on the input struct and the task of adding it to the command data buffer and retrieving back from the buffer when processing inputs will be handled automatically via code generated systems. For this to work it is required to have input gathering and input processing (like movement system) set up in two separate systems.

NOTE
It is required that you use the GhostOwner functionality, for example by checking the Has Owner checkbox in the ghost authoring component for this to work.

NOTE
Per prefab overrides done in the ghost authoring component inspector are disabled for input components and their companion buffer. You can add a ghost component attribute on the input component in code and it will apply to the buffer as well.

Because input struct implementing IInputComponentData are baked by ICommandData, [the 1024 bytes limit for the payload](ICommandData serialization and payload limit) also apply.

Input events
By using the InputEvent type within IInputComponentData inputs you can guarantee one off events (for example gathered by UnityEngine.Input.GetKeyDown) will be synchronized properly with the server and registered exactly once. Even when the exact input tick where the input event was first registered is dropped on its way to the server.

How it works
Given an input component data you'll have these systems set up.

Gather input system (Client loop)
Take input events and save them in the input component data. This happens in GhostInputSystemGroup.
Process input system (Server or prediction loop)
Take current input component and process the values. This usually happens in PredictedSimulationSystemGroup.
With IInputComponentData netcode handling it looks like this with code generated systems.

Gather input system (Client loop)
Take input events and save them in the input component data. This happens in GhostInputSystemGroup.
Copy input to command buffer (Client loop)
Take current input data component and add to command buffer, also recording current tick
Apply inputs for current tick to input component data (Server or prediction loop)
Retrieve inputs from command buffer for current tick and apply to input component. With prediction multiple input values could be applied as prediction rolls back (see Prediction).
Process input system (Server or prediction loop)
Take current input component and process the values. This _usually happens in PredictedSimulationSystemGroup._
The first and last steps are the same as with the single player input handling, and these are the only systems you need to write/manage. An important difference, with netcode enabled input, is that the processing system can be called multiple times per tick as previous ticks (rollback) are handled.

Example code
Simple input values for character movement (with jumping):

using Unity.Entities;
using Unity.NetCode;

[GenerateAuthoringComponent]
public struct PlayerInput : IInputComponentData
{
    public int Horizontal;
    public int Vertical;
    public InputEvent Jump;
}
Input gathering system, it basically takes current inputs and applies to the input component data on the local players entity.

[UpdateInGroup(typeof(GhostInputSystemGroup))]
[AlwaysSynchronizeSystem]
public partial class GatherInputs : SystemBase
{
    protected override void OnCreate()
    {
        RequireForUpdate<PlayerInput>();
    }

    protected override void OnUpdate()
    {
        bool jump = UnityEngine.Input.GetKeyDown("space");
        bool left = UnityEngine.Input.GetKey("left");
        //...

        var networkId = GetSingleton<NetworkId>().Value;
        Entities.WithName("GatherInput").WithAll<GhostOwnerIsLocal>().ForEach((ref PlayerInput inputData) =>
            {
                inputData = default;

                if (jump)
                    inputData.Jump.Set();
                if (left)
                    inputData.Horizontal -= 1;
                //...
            }).ScheduleParallel();
    }
}
Processing input system, takes current input values stored on the players input component and applies the equivalent movement actions.

    [UpdateInGroup(typeof(PredictedSimulationSystemGroup))]
    public partial class ProcessInputs : SystemBase
    {
        protected override void OnCreate()
        {
            RequireForUpdate<PlayerInput>();
        }
        protected override void OnUpdate()
        {
            var movementSpeed = Time.DeltaTime * 3;
            Entities.WithAll<Simulate>().WithName("ProcessInputForTick").ForEach(
                (ref PlayerInput input, ref Translation trans, ref PlayerMovement movement) =>
                {
                    if (input.Jump.IsSet)
                        movement.JumpVelocity = 10; // start jump routine

                    // handle jump event logic, movement logic etc
                }).ScheduleParallel();
        }
    }
Manual serialization
In order to implement serialization manually you need to add the [NetCodeDisableCommandCodeGen] attribute to the struct implementing the ICommandData interface.

You will also need to create a struct implementing ICommandDataSerializer<T> - where <T> is your ICommandData struct.

ICommandDataSerializer has two Serialize and two Deserialize methods: one pair for raw values, and one pair for delta compressed values. The system sends multiple inputs in each command packet. The first packet contains raw data but the rest are compressed using delta compression. Delta compression compresses inputs well because the rate of change is low.

As well as creating a struct you need to create specific instances of the generic systems CommandSendSystem and CommandReceiveSystem. To do this, extend the base system, for example with

[UpdateInGroup(typeof(CommandSendSystemGroup))]
[BurstCompile]
public partial struct MyCommandSendCommandSystem : ISystem
{
    CommandSendSystem<MyCommandSerializer, MyCommand> m_CommandSend;
    [BurstCompile]
    struct SendJob : IJobChunk
    {
        public CommandSendSystem<MyCommandSerializer, MyCommand>.SendJobData data;
        public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex,
            bool useEnabledMask, in v128 chunkEnabledMask)
        {
            data.Execute(chunk, unfilteredChunkIndex);
        }
    }
    [BurstCompile]
    public void OnCreate(ref SystemState state)
    {
        m_CommandSend.OnCreate(ref state);
    }
    [BurstCompile]
    public void OnUpdate(ref SystemState state)
    {
        if (!m_CommandSend.ShouldRunCommandJob(ref state))
            return;
        var sendJob = new SendJob{data = m_CommandSend.InitJobData(ref state)};
        state.Dependency = sendJob.Schedule(m_CommandSend.Query, state.Dependency);
    }
}
[UpdateInGroup(typeof(CommandReceiveSystemGroup))]
[BurstCompile]
public partial struct MyCommandReceiveCommandSystem : ISystem
{
    CommandReceiveSystem<MyCommandSerializer, MyCommand> m_CommandRecv;
    [BurstCompile]
    struct ReceiveJob : IJobChunk
    {
        public CommandReceiveSystem<MyCommandSerializer, MyCommand>.ReceiveJobData data;
        public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex,
            bool useEnabledMask, in v128 chunkEnabledMask)
        {
            data.Execute(chunk, unfilteredChunkIndex);
        }
    }
    [BurstCompile]
    public void OnCreate(ref SystemState state)
    {
        m_CommandRecv.OnCreate(ref state);
    }
    [BurstCompile]
    public void OnUpdate(ref SystemState state)
    {
        var recvJob = new ReceiveJob{data = m_CommandRecv.InitJobData(ref state)};
        state.Dependency = recvJob.Schedule(m_CommandRecv.Query, state.Dependency);
    }
}
