using UnityEngine;
using UnityEditor;
using UnityEngine.Tilemaps;
using Unity.Mathematics;
using UnityEditor.Tilemaps;
using UnityEditor.TerrainTools;
using System;
using UnityEngine.UIElements;
using UnityEditor.EditorTools;

public class TilemapEditorWindow : EditorWindow
{
    string[] options;
    int index = 0;
    Grid selectedGrid;
    private Vector2Int m_PreviousMouseGridPosition;

    Vector2Int m_MouseGridPosition;
    Vector2 m_MousePosition;
    bool m_MouseGridPositionChanged = false;
    bool m_PositionChangeRepaintDone = false;
    private const int k_MaxMouseCellDelta = 500;
    private int sceneViewTransformHash;
    protected Vector2Int? m_PreviousMove;
    protected Vector2Int? m_MarqueeStart;
    public enum MarqueeType { None = 0, Pick, Box, Select }
    private MarqueeType m_MarqueeType = MarqueeType.None;
    private bool m_IsExecuting;
    private Type m_TypeBeforeExecution;
    private int m_ZPosition;
    [MenuItem("Window/Tilemap Editor")]
    public static void ShowWindow()
    {
        GetWindow<TilemapEditorWindow>("Tilemap Editor");
    }


   

    private void OnGridSelectionChanged()
    {
        SceneView.RepaintAll();
    }
    private void OnDisable()
    {
        GridSelection.gridSelectionChanged -= OnGridSelectionChanged;
        // Unsubscribe from the scene view change event
        SceneView.duringSceneGui -= OnSceneGUI;
    }
    private void OnEnable()
    {
        var grids = FindObjectsOfType<Grid>();
        options = new string[grids.Length];
        for (int i = 0; i < grids.Length; i++)
        {
            options[i] = grids[i].name;
        }
        if (grids.Length > 0)
        {
            selectedGrid = grids[0];
        }
        SceneView.duringSceneGui += OnSceneGUI;
        GridSelection.gridSelectionChanged += OnGridSelectionChanged;
        
    }
    private void OnMouseLeave()
    {
        if (GridPaintingState.activeBrushEditor != null)
            GridPaintingState.activeBrushEditor.OnMouseLeave();
      
    }

    private void OnMouseEnter(SceneView sceneView)
    {
        if (GridPaintingState.activeBrushEditor != null)
            GridPaintingState.activeBrushEditor.OnMouseEnter();
        
        UpdateMouseGridPosition(true);
        ResetPreviousMousePositionToCurrentPosition();
    }

    private void OnGUI()
    {
        GUILayout.Label("Select Grid", EditorStyles.boldLabel);

        index = EditorGUILayout.Popup(index, options);

       

        GUILayout.Label("You selected: " + options[index], EditorStyles.boldLabel);
        GUILayout.Label("Mouse Grid Position: " + m_MouseGridPosition, EditorStyles.boldLabel);
        if (m_MouseGridPositionChanged && !m_PositionChangeRepaintDone)
        {
            Repaint();
            m_PositionChangeRepaintDone = true;
        }
    }

    private void HandleMouseEnterLeave(SceneView sceneView)
    {
        if (GridPaintingState.isEditing)
        {
            if (Event.current.type == EventType.MouseEnterWindow)
            {
                OnMouseEnter(sceneView);
            }
            else if (Event.current.type == EventType.MouseLeaveWindow)
            {
                OnMouseLeave();
            }
            // Case 1043365: When docked, the docking area is considered part of the window and MouseEnter/LeaveWindow events are not considered when entering the docking area
            else if (sceneView.docked)
            {
                var guiPoint = Event.current.mousePosition;
                var sceneViewPosition = GetSceneViewPositionRect(sceneView);
                if (sceneViewPosition.Contains(guiPoint))
                {
                  
                        OnMouseEnter(sceneView);
                    
                }
                else
                    OnMouseLeave();
            }
        }
    }
    bool IsMouseUpInWindow() { return Event.current.type == EventType.MouseUp; }

    private void HandleSelectTool()
    {
        Event evt = Event.current;

        if (evt.type == EventType.MouseDown && evt.button == 0)
        {
            m_PreviousMove = null;
            m_MarqueeStart = m_MouseGridPosition;
            m_MarqueeType = MarqueeType.Select;

           // GUIUtility.hotControl = m_PermanentControlID;
            Event.current.Use();
        }
        if (evt.rawType == EventType.MouseUp && evt.button == 0 && m_MarqueeStart.HasValue)
        {
            if (IsMouseUpInWindow() && m_MarqueeType == MarqueeType.Select)
            {
                RectInt rect = GetMarqueeRect(m_MarqueeStart.Value, m_MouseGridPosition);
           //     Select(new BoundsInt(new Vector3Int(rect.xMin, rect.yMin, 1), new Vector3Int(rect.size.x, rect.size.y, 1)));
                Event.current.Use();
            }
            m_MarqueeStart = null;
            m_MarqueeType = MarqueeType.None;
            SceneView.RepaintAll();
            GUIUtility.hotControl = 0;
        }
        if (evt.type == EventType.KeyDown && evt.keyCode == KeyCode.Escape && !m_MarqueeStart.HasValue && !m_PreviousMove.HasValue)
        {
           // ClearGridSelection();
            Event.current.Use();
        }
    }


    /*
    public static void Select(Object target, BoundsInt bounds)
    {
        GridSelection newSelection = CreateInstance<GridSelection>();
        newSelection.m_PreviousSelection = Selection.activeObject;
        newSelection.m_Target = target as GameObject;
        newSelection.m_Position = bounds;
        newSelection.m_OriginalPalette = null;

        Selection.activeObject = newSelection;
        if (gridSelectionChanged != null)
            gridSelectionChanged();
    }*/

    public static RectInt GetMarqueeRect(Vector2Int p1, Vector2Int p2)
    {
        return new RectInt(
            Math.Min(p1.x, p2.x),
            Math.Min(p1.y, p2.y),
            Math.Abs(p2.x - p1.x) + 1,
            Math.Abs(p2.y - p1.y) + 1
        );
    }
    void CallOnSceneGUI()
    {
        var gridLayout = selectedGrid as GridLayout;
        RectInt rect = new RectInt(GridSelection.position.xMin, GridSelection.position.yMin, GridSelection.position.size.x, GridSelection.position.size.y);
            BoundsInt brushBounds = new BoundsInt(new Vector3Int(rect.x, rect.y, 1), new Vector3Int(rect.width, rect.height, 1));
            OnSceneGUIInternal(gridLayout, brushBounds);
        
    }
    internal static void OnSceneGUIInternal(GridLayout gridLayout, BoundsInt position)
    {
        if (Event.current.type != EventType.Repaint)
            return;

      
                Color color = Styles.activeColor;
                DrawGridMarquee(gridLayout, position, color);
       
    }
    private static class Styles
    {
        public static readonly Color activeColor = new Color(1f, .5f, 0f);
        public static readonly Color executingColor = new Color(1f, .75f, 0.25f);
    }
    public static void DrawGridMarquee(GridLayout gridLayout, BoundsInt area, Color color)
    {
        if (gridLayout == null || gridLayout.cellLayout != GridLayout.CellLayout.Isometric)
            return;

        var cellStride = gridLayout.cellSize + gridLayout.cellGap;
        var cellGap = Vector3.one;
        if (!Mathf.Approximately(cellStride.x, 0f))
        {
            cellGap.x = gridLayout.cellSize.x / cellStride.x;
        }
        if (!Mathf.Approximately(cellStride.y, 0f))
        {
            cellGap.y = gridLayout.cellSize.y / cellStride.y;
        }

        Vector3[] cellLocals =
        {
        gridLayout.CellToLocal(new Vector3Int(area.xMin, area.yMin, area.zMin)),
        gridLayout.CellToLocalInterpolated(new Vector3(area.xMax - 1 + cellGap.x, area.yMin, area.zMin)),
        gridLayout.CellToLocalInterpolated(new Vector3(area.xMax - 1 + cellGap.x, area.yMax - 1  + cellGap.y, area.zMin)),
        gridLayout.CellToLocalInterpolated(new Vector3(area.xMin, area.yMax - 1 + cellGap.y, area.zMin))
    };

    //    HandleUtility.ApplyWireMaterial();
        GL.PushMatrix();
        GL.MultMatrix(gridLayout.transform.localToWorldMatrix);
        GL.Begin(GL.LINES);
        GL.Color(color);
        int i = 0;

        for (int j = cellLocals.Length - 1; i < cellLocals.Length; j = i++)
            DrawBatchedLine(cellLocals[j], cellLocals[i]);

        GL.End();
        GL.PopMatrix();
    }
    public static void DrawBatchedLine(Vector3 p1, Vector3 p2)
    {
        GL.Vertex3(p1.x, p1.y, p1.z);
        GL.Vertex3(p2.x, p2.y, p2.z);
    }
    private void OnSceneGUI(SceneView sceneView)
    {
        // Your existing HandleMouseEnterLeave method goes here...

        // Your existing CallOnSceneGUI method goes here...
        HandleMouseEnterLeave(sceneView);

        CallOnSceneGUI();

        // Only handle the currently active scene view
        if (sceneView != SceneView.lastActiveSceneView)
            return;

        if (SceneView.lastActiveSceneView != null)
        {
            var currentSceneViewTransformHash = SceneView.lastActiveSceneView.camera.transform.localToWorldMatrix.GetHashCode();
            UpdateMouseGridPosition(currentSceneViewTransformHash != sceneViewTransformHash);
            sceneViewTransformHash = currentSceneViewTransformHash;
            Debug.Log("SceneView.lastActiveSceneView != null");
        }
        else
        {
            Debug.Log("SceneView.lastActiveSceneView == null");
        }


        // Validate that grid is not totally parallel to view (+-5 degrees), otherwise tiles could be accidentally painted on large positions

        // Insert your new logic here

    }
    private void MouseGridPositionChanged()
    {
        m_MouseGridPositionChanged = true;
        m_PositionChangeRepaintDone = false;
    }
    private Rect GetSceneViewPositionRect(SceneView sceneView)
    {
        return new Rect(0, 0, sceneView.position.width, sceneView.position.height);

    }

    private void UpdateMouseGridPosition(bool forceUpdate = false)
    {
        if (Event.current.type == EventType.MouseDrag
            || Event.current.type == EventType.MouseMove
            || Event.current.type == EventType.MouseDown
            || Event.current.type == EventType.DragUpdated
            || forceUpdate)
        {
            m_MousePosition = Event.current.mousePosition;
            var newGridPosition = ScreenToGrid(m_MousePosition, 0f);
            if (newGridPosition != m_MouseGridPosition)
            {
                var delta = newGridPosition - m_MouseGridPosition;
                if (Math.Abs(delta.x) > k_MaxMouseCellDelta)
                    newGridPosition.x = m_MouseGridPosition.x + Math.Sign(delta.x) * k_MaxMouseCellDelta;
                if (Math.Abs(delta.y) > k_MaxMouseCellDelta)
                    newGridPosition.y = m_MouseGridPosition.y + Math.Sign(delta.y) * k_MaxMouseCellDelta;
                ResetPreviousMousePositionToCurrentPosition();
                m_MouseGridPosition = newGridPosition;
                MouseGridPositionChanged();
            }
            else if (!forceUpdate || Event.current.type == EventType.MouseMove)
            {
                // Don't need to do anything here
                                    m_MouseGridPositionChanged = false;

            }
        }
    }

    protected void ResetPreviousMousePositionToCurrentPosition()
    {
        m_PreviousMouseGridPosition = m_MouseGridPosition;
    }
    void CallOnPaintSceneGUI()
    {
        // Только если есть выделение.
   

        // Берём размеры выделения.
        RectInt rect = new RectInt(GridSelection.position.xMin, GridSelection.position.yMin, GridSelection.position.size.x, GridSelection.position.size.y);

        // Определяем layoutGrid.
        var layoutGrid = selectedGrid as GridLayout;

        // Устанавливаем Bounds для кисти.
        BoundsInt brushBounds = new BoundsInt(new Vector3Int(rect.x, rect.y, 1), new Vector3Int(rect.width, rect.height, 1));

        // Если у нас есть активный редактор кисти, вызываем его метод для отрисовки на сцене.
        // Если нет, то вызываем стандартный метод.
       
           OnPaintSceneGUIInternal(layoutGrid, brushBounds
                );
        
    }

    internal static void OnPaintSceneGUIInternal(GridLayout gridLayout, BoundsInt position)
    {
        if (Event.current.type != EventType.Repaint)
            return;

        Color color = Color.white;
     
        color = Styles.executingColor;
     

       
        DrawGridMarquee(gridLayout, position, color);
    }

    protected bool executing
    {
        get { return m_IsExecuting; }
        set
        {
            var isExecuting = value ;
            if (isExecuting != m_IsExecuting)
            {
                
            }
            m_IsExecuting = isExecuting;
        }
    }
    private Vector2Int ScreenToGrid(Vector2 screenPosition, float zPosition)
    {
        if (selectedGrid != null)
        {
            var transform = selectedGrid.transform;
            var plane = GetGridPlane(selectedGrid);
            var ray = HandleUtility.GUIPointToWorldRay(screenPosition);
            if (plane.Raycast(ray, out float enter))
            {
                var hitPoint = ray.GetPoint(enter);
                var localPosition = transform.InverseTransformPoint(hitPoint);
         
                var cell = LocalToGrid(selectedGrid, localPosition);
                return new Vector2Int(cell.x, cell.y);
            }
        }
        return Vector2Int.zero;
    }

    Vector3Int LocalToGrid(GridLayout gridLayout, Vector3 local)
    {
        return gridLayout.LocalToCell(local);
    }

    private Vector3 GetGridForward(GridLayout gridLayout)
    {
        switch (gridLayout.cellSwizzle)
        {
            case GridLayout.CellSwizzle.XYZ:
                return gridLayout.transform.forward * -1f;
            case GridLayout.CellSwizzle.XZY:
                return gridLayout.transform.up * -1f;
            case GridLayout.CellSwizzle.YXZ:
                return gridLayout.transform.forward;
            case GridLayout.CellSwizzle.YZX:
                return gridLayout.transform.up;
            case GridLayout.CellSwizzle.ZXY:
                return gridLayout.transform.right;
            case GridLayout.CellSwizzle.ZYX:
                return gridLayout.transform.right * -1f;
        }
        return gridLayout.transform.forward * -1f;
    }

    

    private Plane GetGridPlane(Grid planeForGrid)
    {
        return new Plane(GetGridForward(planeForGrid), planeForGrid.transform.position);
    }




   
}
