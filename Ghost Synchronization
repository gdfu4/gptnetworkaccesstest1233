Ghost snapshots
A ghost is a networked object that the server simulates. During every frame, the server sends a snapshot of the current state of all ghosts to the client. The client presents them, but cannot directly control or affect them because the server owns them.

The ghost snapshot system synchronizes entities which exist on the server to all clients. To make it perform properly, the server processes per ECS chunk rather than per entity. On the receiving side the processing is done per entity. This is because it is not possible to process per chunk on both sides, and the server has more connections than clients.

Why use Ghosts? Ghosts vs. RPCs
Ghost Snapshot Synchronization ("Eventual Consistency") Use-Cases
To replicate spatially local, ephemeral, and relevant per-entity data.
To enable client prediction of ghost entities, which is the most effective latency-hiding multiplayer technique.
RPC Use-Cases
High-level game flow events. Example: Making every client do a certain thing, like load a specific level.
Sending one-shot, non-predicted commands from the client to the server. Example: Join this Squad. Send a chat message. Unmute this player. Request to exit this realm. etc.
Key Differences:
RPCs are "one-shot" events, and are thus not automatically persisted. Example: If you send an RPC when a treasure chest is opened, if a player disconnects and reconnects, the chest will appear closed.
Ghost data persists for the lifetime of its Ghost entity (and the lifetime of the ghost entity is itself replicated). Therefore, long-lived user-interactable entities should have their persistent state stored in Ghost components. Example: A chests FSM can be stored as an enum on a Component. If a player opens the chest, disconnects, then reconnects, they will re-receive the chest, as well as its open state.
RPCs are sent as reliable packets, while ghosts snapshots are unreliable (with "eventual consistency").
RPC data is sent and received as it is, while ghost data goes through optimizations like diff and delta-compression, and can go through value smoothing when received.
RPCs are not tied to any particular tick, or other snapshot timing data. They are simply processed on the frame that they are received.
Ghost snapshot data can work with interpolation and prediction (with snapshot history), and thus history, rollback, and resimulation.
Ghost snapshot data can be bandwidth optimized via relevancy and importance. RPCs are either broadcast, or sent to a single client.
Authoring Ghosts
Ghost can be authored in the editor by creating a Prefab with a GhostAuthoringComponent.

Ghost Authoring Component

The GhostAuthoringComponent has a small editor which you can use to configure how Netcode synchronizes the Prefab.
You must set the Name, Importance, Supported Ghost Mode, Default Ghost Mode and Optimization Mode property on each ghost.
Netcode for Entities uses the Importance property to control which entities are sent when there is not enough bandwidth to send all. A higher value makes it more likely that the ghost will be sent.

You can select from three different Supported Ghost Mode types:

All - this ghost supports both being interpolated and predicted.
Interpolated - this ghost only supports being interpolated, it cannot be spawned as a predicted ghost.
Predicted - this ghost only supports being predicted, it cannot be spawned as a interpolated ghost.
You can select from three different Default Ghost Mode types:

Interpolated - all ghosts Unity receives from the server are treated as interpolated.
Predicted - all ghosts Unity receives from the server are treated as predicted.
Owner predicted - the ghost is predicted for the client that owns it, and interpolated for all other clients. When you select this property, you must also add a GhostOwner and set its NetworkId field in your code. Unity compares this field to each clients’ network ID to find the correct owner.
You can select from two different Optimization Mode types:

Dynamic - the ghost will be optimized for having small snapshot size both when changing and when not changing.
Static - the ghost will not be optimized for having small snapshot size when changing, but it will not be sent at all when it is not changing.
Replicating Components and Buffers
Netcode for Entities uses C# attributes to configure which components and fields are synchronized as part of a ghost. There are three fundamental attributes you can use:

NetCode Attribute	Usage
GhostFieldAttribute	The GhostFieldAttribute should be used to mark which component (or buffer) fields should be serialised.
The attribute can be added to struct fields and properties.
Once a component has at least one field marked with [GhostField], it becomes replicated, and will be transmitted as part of the ghost data.
GhostEnabledBitAttribute	Similarly, the GhostEnabledBitAttribute should be used on an IEnableableComponent struct definition, to denote that the enabled bit for this component should be serialized.
Once a component is flagged with [GhostEnabledBit], its enabled-bit will be replicated, and thus transmitted as part of the ghost data.
GhostComponentAttribute	The GhostComponentAttribute should be used on a ComponentType struct definition to:
- Declare for which version of the Prefab the component should be present.
- Declare if the component should be serialised also for child entities.
- Declare to which subset of clients a component should be replicated.
Authoring component serialization
To signal the Netcode for Entities that a component should be serialised, you need to add a [GhostField] attribute to the values you want to send.

public struct MySerialisedComponent : IComponentData
{
    [GhostField]public int MyIntField;
    [GhostField(Quantization=1000)]public float MyFloatField;
    [GhostField(Quantization=1000, Smoothing=SmoothingAction.Interpolate)]public float2 Position;
    public float2 NonSerialisedField;
    ...
}
For a component to support serialization, the following conditions must be met:

The component itself must be declared as public.
Only public members are considered. Adding a [GhostField] to a private member has no effect.
The GhostField can specify Quantization for floating point numbers (and other supported types, see Ghost Type Templates). The floating point number will be multiplied by this Quantization value, and converted to an integer, in order to save bandwidth. Specifying a Quantization is mandatory for floating point numbers. To send a floating point number unquantized; you have to explicitly specify [GhostField(Quantization=0)].
The GhostField Composite flag controls how the delta compression computes the change fields bitmask for non primitive fields (i.e. structs). When set to true, the delta compression will generate only 1 bit to indicate if the entire struct contains any changes. If Composite is false, each field will have its own change-bit. Thus, use Composite=true if all fields are typically modified together (example: GUID).
The GhostField SendData flag (which defaults to true) can be used to instruct code-generation to not include this field in the serialization data. This is particularly useful for non primitive members (like structs), which will have all fields serialized by default.
The GhostField also has a Smoothing property, which controls how the field will be updated, when the ghost is in GhostMode.Interpolated. I.e. When a given client is not predicting said ghost. Possible values are:
SmoothingAction.Clamp - Every time a snapshot is received, jump (i.e. clamp) the client value to the latest snapshot value.
SmoothingAction.Interpolate - Every frame, interpolate the field between the last two snapshot values. If no data is available for the next tick, clamp to the latest value.
SmoothingAction.InterpolateAndExtrapolate - Every frame, interpolate the field between the last two snapshot values. If no data is available for the next tick, the next value is linearly extrapolated using the previous two snapshot values. Extrapolation is limited (i.e. clamped) via ClientTickRate.MaxExtrapolationTimeSimTicks.
GhostField MaxSmoothingDistance allows you to disable interpolation when the values change more than the specified limit between two snapshots. This is useful for dealing with teleportation, for example.
Finally the GhostField has a SubType property which can be set to an integer value to use special serialization rules supplied for that specific field.
![NOTE] Speaking of teleportation: To support short range teleportation, you'd need some other replicated bit to distinguish a teleport from a move (lerp).

Authoring dynamic buffer serialization
Dynamic buffers serialization is natively supported. Unlike components, to replicate a buffer, all public fields must be marked with at [GhostField] attribute.

![NOTE] This restriction has been added to guarantee that: In the case where an element is added to the buffer, when it is replicated to the client, all fields on said element will have meaningful values. This restriction may be removed in the future (e.g. by instead, defaulting this undefined behaviour to default(T)).

public struct SerialisedBuffer : IBufferElementData
{
    [GhostField]public int Field0;
    [GhostField(Quantization=1000)]public float Field1;
    [GhostField(Quantization=1000)]public float2 Position;
    public float2 NonSerialisedField; // This is an explicit error!
    private float2 NonSerialisedField; // We allow this. Ensure you set this on the client, before reading from it.
    [GhostField(SendData=false)]public int NotSentAndUninitialised; // We allow this. Ensure you set this on the client, before reading from it.
    ...
}
Furthermore, in line with the IComponentData:

The buffer must be declared as public.
Only public members are considered. Adding a [GhostField] to a private member has no effect.
By using the GhostField.SendData you can instrument the serialisation code to skip certain field. In such a case:
the value of the fields that aren't replicated are never altered
for new buffer elements, their content is not set to default and the content is undefined (can be any value).
Dynamic buffers fields don't support SmoothingActions. Thus, the GhostFieldAttribute.Smoothing and GhostFieldAttribute.MaxSmoothingDistance properties will be ignored when used on buffers.

ICommandData and IInputComponentData serialization
ICommandData, being a subclass of IBufferElementData, can also be serialized from the server to clients. As such, the same rules for buffers apply: if the command buffer must be serialized, then all fields must be annotated.

    [GhostComponent()]
    public struct MyCommand : ICommandData
    {
        [GhostField] public NetworkTick Tick {get; set;}
        [GhostField] public int Value;
    }
The same applies when using automated input synchronization with IInputComponentData.

    public struct MyCommand : IInputComponentData
    {
        [GhostField] public int Value;
    }
The command data serialization is particularly useful for implementing RemotePlayerPrediction.

Ghost Field Inheritance
If a [GhostField] is specified for a non primitive field type, the attribute (and some of its properties) are automatically inherited by all the sub-fields which do not themselves implement a [GhostField] attribute. For example:


public struct Vector2
{
    public float x;
    [GhostField(Quantization=100)] public float y;
}

public struct MyComponent : IComponentData
{
    //Value.x will inherit the quantization value specified by the parent definition (1000).
    //Value.y will maintain its original quantization value (100).
    [GhostField(Quantized=1000)] public Vector2 Value;
}
The following properties are not inherited:

SubType - The subtype is always reset to the default
Using the GhostComponentAttribute
The GhostComponentAttribue does not indicate or signal that a component is replicated (that's what the other two attributes are for). Instead, it should be used to instruct the runtime how to handle the component when it comes to:

SendDataForChildEntity denotes whether or not to replicate this component when it is attached to a child of a ghost entity. Replicating child of ghost entities is significantly slower than replicating those ghost root entities. Thus, we default to false. This flag also applies to the [GhostEnabledBit].
PrefabType allows you to remove the component from the specific version of the ghost prefab. Ghost prefabs have three versions: Interpolated Client (IC), Predicted Client (PC), and Server (S). Example: Removing rendering related components from the server world's version of this ghost.
GhostSendType denotes whether or not the component should be sent when the ghost is GhostMode.Predicted vs GhostMode.Interpolated. Example: Only sending PhysicsVelocity when you're actually predicting the physics of a ghost.
SendToOwnerType denotes whether or not to replicate this data when the ghost is owned, vs not owned, vs either. Example: Replicating input commands only to other players (as you already know your own).
[GhostComponent(PrefabType=GhostPrefabType.All, SendTypeOptimization=GhostSendType.OnlyInterpolatedClients, SendDataForChildEntity=false)]
public struct MyComponent : IComponentData
{  
    [GhostField(Quantized=1000)] public float3 Value;
}
PrefabType Details
To change which versions of a Ghost Prefab a component is available on, use PrefabType in a GhostComponentAttribute on the component. PrefabType can be on of the these types:

InterpolatedClient - the component is only available on clients, and only when the ghost is interpolated.
PredictedClient - the component is only available on clients, and only when the ghost is predicted.
Client - the component is only available on clients, regardless of the GhostMode (e.g. either predicted or interpolated).
Server - the component is only available on the server.
AllPredicted - the component is only available on the server, and on clients, only when the ghost is predicted.
All - the component is available on the server and all clients.
For example, if you add [GhostComponent(PrefabType=GhostPrefabType.Client)] to RenderMesh, the ghost won’t have a RenderMesh when it is instantiated on the server world, but it will have it when instantiated on the client world.

NOTE
Runtime Prediction Switching therefore has the potential to add and remove components on a ghost, live.

SendTypeOptimization Details
A component can set SendTypeOptimization in the GhostComponentAttribute to control which clients the component is sent to, whenever a ghost type is known at compile time. The available modes are:

None - the component is never sent to any clients. Netcode will not modify the component on the clients which do not receive it.
Interpolated - the component is only sent to clients which are interpolating the ghost.
Predicted - the component is only sent to clients which are predicting the ghost.
All - the component is sent to all clients.
A component can also set SendDataForChildEntity to true in order to change the default (of not serializing children), allowing this component to be serialized when on a child.

A component can also set SendToOwner in the GhostComponentAttribute to specify if the component should be sent to client who owns the entity. The available values are:

SendToOwner - the component is only sent to the client who own the ghost
SendToNonOwner - the component is sent to all clients except the one who owns the ghost
All - the component is sent to all clients.
![NOTE] By setting either the SendTypeOptimisation and/or SendToOwner (to specify to which types of client(s) the component should be replicated to), will not affect the presence of the component on the prefab, nor modify the component on the clients which did not receive it.

How to add serialization support for custom Types
The types you can serialize via GhostFieldAttribute are specified via templates. You can see the default supported types [here](ghost-types-templates.md#Supported Types)

In addition to the default out-of-the-box types you can also:

add your own templates for new types.
provide a custom serialization templates for a types and target by using the SubTypes property of the GhostFieldAttribute.
Please check how to [use and write templates](ghost-types-templates.md#Defining additional templates) for more information on the topic.

![NOTE] Writing templates is non-trivial. If it is possible to replicate the type simply by adding GhostFields, it's often easier to just do so. If you do not have access to a type, create a Variant instead (see section below).

Ghost Component Variants
The GhostComponentVariationAttribute is special attribute tha can be used to declare at compile time a "replication schema" for a type, without the need to markup the fields in the original type, or the original type itself.

![NOTE]This new declared type act as proxy from a code-generation perspective. Instead of using the original type, the code-generation system use the declared "variant" to generate a specific version of the serialization code. ![NOTE] Ghost components variants for IBufferElementData are not fully supported.

The GhostComponentVariationAttribute has some specific use-cases in mind:

Variants allow user-code (you) to declare serialization rules for a component that you don't have direct write access too (i.e. components in a package or external assembly). Example: Making Unity.Entities.LocalTransform replicated.
Generate multiple serialization strategies for a single type (i.e: provide multiple ways to replicate a single type, allowing individual ghosts to select their version). Example: Replicate only the Yaw value of Unity.Entities.LocalRotation, or the full quaternion.
Strip components (i.e: RenderMesh) from certain prefab types (e.g. from the Server) by overriding or adding a GhostComponentAttribute to the type, without changing the original declaration.
    [GhostComponentVariation(typeof(LocalTransform), "Transform - 2D")]
    [GhostComponent(PrefabType=GhostPrefabType.All, SendTypeOptimization=GhostSendType.AllClients)]
    public struct PositionRotation2d
    {
        [GhostField(Quantization=1000, Smoothing=SmoothingAction.InterpolateAndExtrapolate, SubType=GhostFieldSubType.Translation2D)]
        public float3 Position;
        [GhostField(Quantization=1000, Smoothing=SmoothingAction.InterpolateAndExtrapolate, SubType=GhostFieldSubType.Rotation2D)]
        public quaternion Rotation;
    }
In the example above, the PositionRotation2d Variation will generate serialization code for LocalTransform, using the properties and the attribute present in the variant declaration.

The attribute constructor takes a few arguments:

The Type type of the ComponentType you want to specify the variant for (ex: LocalTransform).
The user-friendly string variantName, which will allow you to better interpret GhostAuthoringInspectionComponent UI.
Then, for each field in the original struct (in this case, LocalTransform) that you wish to replicate, you should add a GhostField attribute like you usually do, and define the field identically to that of the base struct.

~[NOTE] Only members that are present in the component type are allowed. Validation occurs at compile time, and exceptions are thrown in case this rule is not respected.

An optional GhostComponentAttribute attribute can be added to the variant to further specify the component serialization properties.

It is possible to declare multiple serialization variant for a component (example: 2D and 3D variations for LocalRotation).

NOTE
If you only define only one Variant for a ComponentType, it becomes the default serialization strategy for that type automatically.

Preventing a component from supporting Variations
There are cases where you'd like to prevent a component from having its serialization modified via Variants. Example: From the NetCode package itself, we must always replicate the GhostComponent for netcode systems to work properly, so we don't let user-code (you) modify serialization rules for it).

Thus, to prevent a component from supporting variation, use the DontSupportPrefabOverridesAttribute attribute. An error will be reported at compile time, if a GhostComponentVariation is defined for that type.

Specify which variant to use on a Ghost Prefab
Using the GhostAuthoringInspectionComponent MonoBehaviour in conjunction with the GhostAuthoringComponent MonoBehaviour, it is possible to select what serialization variants to use on a per-prefab basis. You can choose a Variant for each individual component (including the ability to set the special-case variant: DontSerializeVariant).

Ghost Authoring Variants

All variants for that specific component type present in the project will be show in a dropbox selection.
To modify how children of Ghost prefabs are replicated, add a GhostAuthoringInspectionComponent to each individual child.

NOTE
The GhostAuthoringInspectionComponent is also an incredibly valuable debugging tool. Add it to a Ghost Prefab (or one of its children) to view all replicated types on said Ghost, and to diagnose why a specific type is not replicating in the way you'd expect.

Assigning a default variant to use for a Type
In cases where multiple variants are present for a type, Netcode may be unable to infer which Variant should be used. If the "Default Serializer" for the Type is replicated, it'll default to it. If not, it is considered a conflict, and you'll get runtime exceptions when creating any netcode world (including Baking worlds). We use a built-in, deterministic, fallback method to guess which variant you likely want, but, in general, it is the users responsibility to indicate what Variant should be the default here.

To setup which variant to use as the default for a given type, you need to create a system that inherits from DefaultVariantSystemBase class, and implements the RegisterDefaultVariants method.

using System.Collections.Generic;
using Unity.Entities;
using Unity.Transforms;

namespace Unity.NetCode.Samples
{
    sealed class DefaultVariantSystem : DefaultVariantSystemBase
    {
        protected override void RegisterDefaultVariants(Dictionary<ComponentType, Rule> defaultVariants)
        {
            defaultVariants.Add(typeof(LocalTransform), Rule.OnlyParents(typeof(TransformDefaultVariant)));
        }
    }
}
This example code would make sure the default LocalTransform variant to us as default is the TransformDefaultVariant. For more information, please refer to the DefaultVariantSystemBase documentation.

NOTE
This is the recommended approach to setup the default Variant for a Ghost "project-wide". Prefer DefaultVariantSystemBase over direct Variant manipulation (via the GhostAuthoringInspectionComponent overrides).

Special Variant Types
Special Built-in Variant	Details
ClientOnlyVariant	Use this to specify that a given ComponentType should only appear on client worlds.
ServerOnlyVariant	The inverse.
DontSerializeVariant	Use this to disable serialization of a Type entirely. I.e. Use it to ignore replication attributes ([GhostField] and [GhostEnabledBit]).
using System.Collections.Generic;
using Unity.Entities;
using Unity.Transforms;

namespace Unity.NetCode.Samples
{
    sealed class DefaultVariantSystem : DefaultVariantSystemBase
    {
        protected override void RegisterDefaultVariants(Dictionary<ComponentType, Rule> defaultVariants)
        {
            defaultVariants.Add(typeof(SomeClientOnlyThing), Rule.ForAll(typeof(ClientOnlyVariant)));
            defaultVariants.Add(typeof(SomeServerOnlyThing), Rule.ForAll(typeof(ServerOnlyVariant)));
            defaultVariants.Add(typeof(NoNeedToSyncThis), Rule.ForAll(typeof(DontSerializeVariant)));
        }
    }
}
You can also manually pick the DontSerializeVariant in the ghost component on ghost prefabs (via the GhostAuthoringInspectionComponent).

Assign variants and override GhostComponentAttribute settings on ghost prefabs
It is possible to override the following meta-data on per-prefab basis, by using the GhostAuthoringInspectionComponent editor.

Ghost Authoring Component

The GhostAuthoringInspectionComponent should be added to the GameObject you would like to customise. Once added, the editor will show which components present in the runtime entity are replicated.
The editor allow you to: change the following properties:

Change the PrefabType in which the component should be present/replicated.
Change the SendToOptimization for this component (if applicable)
Assign the serialization Variant to use for that component.
It is possible to prevent a component from supporting per-prefab overrides by using the DontSupportPrefabOverrides attribute.
When present, the component can't be customized in the inspector, nor can a programmer add custom or default variants for this type (as that will trigger errors during ghost validation).

For example: The Netcode for Entities package requires the GhostOwner to be added to all ghost types, sent for all ghost types, and serialized using the default variant. Thus, we add the [DontSupportPrefabOverride] attribute to it.

![NOTE] Components on child entities are not serialised by default, thus by default when you look to GhostAuthoringInspectionComponent on a child GameObject you will see that the selected variant for the type is the DontSerializeVariant.

<img src="images/dontserialize-variant.png" alt="DontSerializeVariant" width=600/>

Snapshot visualization tool
To understand what is being put on the wire in the Netcode, you can use the snapshot visualization tool, NetDbg tool.

net debug tool

To open the tool, go to menu: Multiplayer > Open NetDbg, and the tool opens in a browser window. It displays a vertical bar for each received snapshot, with a breakdown of the snapshot’s ghost types, size etc.

To see more detailed information about the snapshot, click on one of the bars.

NOTE
This tool is a prototype. In future versions of the package, it will integrate with the Unity Profiler so you can easily correlate network traffic with memory usage and CPU performance.

Class GhostFieldAttribute
Attribute used to specify how and which fields and properties of IComponentData or IBufferElementData should be replicated. When a component or buffer contains at least one field that is annotated with a GhostFieldAttribute, a struct implementing the component serialization is automatically code-generated.

Inheritance
Object
Attribute
GhostFieldAttribute
Inherited Members
Attribute.GetCustomAttributes(MemberInfo, Type)
Attribute.GetCustomAttributes(MemberInfo, Type, Boolean)
Attribute.GetCustomAttributes(MemberInfo)
Attribute.GetCustomAttributes(MemberInfo, Boolean)
Attribute.IsDefined(MemberInfo, Type)
Namespace: Unity.NetCode
Syntax
[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
public class GhostFieldAttribute : Attribute, _Attribute
Remarks
Note that "enableable components" (IEnableableComponent) will still have their fields replicated, even when disabled. See GhostEnabledBitAttribute to replicate the enabled flag itself.

Properties
Composite
Only applicable on GhostFieldAttributes applied to a non primitive struct containing multiple fields. If this value is not set (a.k.a. false, the default), a 'change bit' will be included 'per field, for every field inside the nested struct'. There will be no 'change bit' for the struct itself. I.e. If a single field inside the sub-struct changes, only that fields 'change bit' will be set. Otherwise (if this Composite bool is set, a.k.a. true), we instead use a single 'change bit' for 'the entire nested struct'. I.e. If any fields inside the sub-struct change, the single 'change bit' for the entire struct will be set. Check the Serialize/Deserialize code-generated methods in Library\NetCodeGenerated_Backup for examples.

Declaration
public bool Composite { get; set; }
Property Value
Type	Description
Boolean	
MaxSmoothingDistance
The maximum distance between two snapshots for which smoothing will be applied. If the value changes more than this between two received snapshots the smoothing action will not be performed.

Declaration
public float MaxSmoothingDistance { get; set; }
Property Value
Type	Description
Single	
Remarks
For quaternions the value specified should be sin(theta / 2) - where theta is the maximum angle you want to apply smoothing for.

Quantization
Floating point numbers will be multiplied by this number and rounded to an integer, enabling better delta-compression via huffman encoding. Specifying a Quantization is mandatory for floating point numbers and not supported for integer numbers. To send a floating point number unquantized, use 0. Examples: Quantization=0 implies full precision. Quantization=1 implies precision of 1f (i.e. round float values to integers). Quantization=2 implies precision of 0.5f. Quantization=10 implies precision of 0.1f. Quantization=20 implies precision of 0.05f. Quantization=1000 implies precision of 0.001f.

Declaration
public int Quantization { get; set; }
Property Value
Type	Description
Int32	
SendData
Default true. If unset (false), instructs code-generation to not include this field in the serialization data. I.e. Do not replicate this field. This is particularly useful for non primitive members (like structs), which will have all fields serialized by default.

Declaration
public bool SendData { get; set; }
Property Value
Type	Description
Boolean	
Smoothing
Default is Clamp.

Declaration
public SmoothingAction Smoothing { get; set; }
Property Value
Type	Description
SmoothingAction	
SubType
Allows you to specify a custom serializer for this GhostField using the GhostFieldSubType API.

Declaration
public int SubType { get; set; }
Property Value
Type	Description
Int32	
Remarks
Why GhostFieldSubType is not an enum: The reason is that there are unfortunately caveats, some due to our compilation pipeline and others due to the limitation of the SourceGenerator api. First: MS SourceGenerator are additive only. That means we cannot modify the syntaxtree, removing or adding nodes to it (not the way Analyzers does). To overcome that limitation, a possible solution to inject the enums literals into the assembly is to use a small IL post processor instead. Because NetCode runtime assembly is re-imported every time a sub-type is added or removed, the assumption was that the IL post-processing will then correctly modify the dll before any dependent dll is compiled. Although it does, and Unity.NetCode.dll contains the correct metadata, the ILPostProcessorRunner run at a later time and some dlls are not compile correctly (depend on timing). With further investigation it might be possible to address that problem, however it seems like fighting against the compilation process again, something we wanted to avoid. Because all of that, a partial class to hold the integral constants it uses instead and users can add new const literals.

Why the AssemblyDefinitionReference? Using source generator to add a partial class directly to NetCode.dll works fine but unfortunately will miss the IDE auto-completion functionality. No IDE at the moment provide support for that out of the box. VS has some workaround for normal C# projects (removing the original file from the solution etc) or by restarting the IDE, but Rider or VSCode does not work the same way. By using the Assembly Definition Reference, we are actually doing in principle the same job and completion works, making the user experience a little more pleasant.

Interface IComponentData
This interface marks structs as 'unmanaged components' and classes as 'managed components'.

Namespace: Unity.Entities
Syntax
[RequireImplementors]
public interface IComponentData : IQueryTypeParameter

Class GhostComponentAttribute
This attribute can be used to tag components to control which ghost prefab variants they are included in and where they are sent for owner predicted ghosts.

Inheritance
Object
Attribute
GhostComponentAttribute
Inherited Members
Attribute.GetCustomAttributes(MemberInfo, Type)
Attribute.GetCustomAttributes(MemberInfo, Type, Boolean)
Attribute.GetCustomAttributes(MemberInfo)
Attribute.GetCustomAttributes(MemberInfo, Boolean)
Attribute.IsDefined(MemberInfo, Type)
Namespace: Unity.NetCode
Syntax
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
public class GhostComponentAttribute : Attribute, _Attribute
Properties
OwnerSendType
Get or sets if a component should be be sent to the prediction owner or not. Some combination of the parameters and OwnerSendType may result in an error or warning at code-generation time.

Declaration
public SendToOwnerType OwnerSendType { get; set; }
Property Value
Type	Description
SendToOwnerType	
PrefabType
Gets or sets the type of prefab where this component should be included on the main entity of the prefab.

Declaration
public GhostPrefabType PrefabType { get; set; }
Property Value
Type	Description
GhostPrefabType	
SendDataForChildEntity
Denotes whether or not this component - when added to a child entity - should send (i.e. replicate) its data. The default behaviour is that Netcode will NOT replicate component and buffer data on children. Why not? It's expensive, as it involves finding child entities in other chunks. Thus, setting this flag to true will enable this (more expensive) serialization of child entities (unless overridden via another "Variant"). Setting to false has no effect (as is the default).

Declaration
public bool SendDataForChildEntity { get; set; }
Property Value
Type	Description
Boolean	
SendTypeOptimization
Gets or sets the type of ghost this component should be sent to if the ghost is owner predicted. Formerly: "OwnerPredictedSendType".

Declaration
public GhostSendType SendTypeOptimization { get; set; }
Property Value
Type	Description
GhostSendType
Ghost Templates
Ghost component types (i.e. all components with a GhostField attribute, or other netcode interfaces) are all handled a certain way during Baking, and by the NetCode code generator, to produce the right code when building players. It's possible to define the desired behavior in code, and on a per-ghost prefab basis, and on a per-component basis.

Supported Types
Inside the package, we have default templates for how to generate serializers (called the "default serializers") for a limited set of types:

bool
Entity
FixedString32Bytes
FixedString64Bytes
FixedString128Bytes
FixedString512Bytes
FixedString4096Bytes
float
float2
float3
float4
byte
sbyte
short
ushort
int
uint
long
ulong
enums (only for int/uint underlying type)
quaternion
double
For certain types (i.e float, double, quaternion ,float2/3/4) multiple templates exists, which handle different ways to serialise the type:

Quantization [Quantized or un-quantized]: Quantized means a float value is sent as an int, with a certain multiplication factor, which sets its precision (e.g. 12.456789 can be sent as 12345 with a quantization factor of 1000). Unquantized means the float will be sent with full precision.
Smoothing method [Clamp, Interpolate, or InterpolateAndExtrapolate]: Denotes how a new value is applied on the client, when a snapshot is received. See docs for SmoothingAction for more details).
Since each of these can change how the source value is serialized, deserialized, and applied on the target, we have multiple serialization templates. Additionally; each template uses different, named regions to handle these cases. The code generator will pick the appropriate regions to generate, and thus bake your user-defined serialization settings for fields on your types, directly into the "Serializer" for your type. You can explore these generated types in the projects Temp/NetCodeGenerated folder (note that they are deleted when Unity is closed).

Changing how a ComponentType is serialized via "Ghost Component Variants"
Ghost Component Variants give you the ability to clobber the "Default Serializer" generated for a given type, replacing it with your own serializer. Variants can also be applied on a per-ghost, per-component basis, via the GhostAuthoringInspectionComponent. See docs through the above link for futher details.

Changing how a ComponentType is serialized via "Ghost Component SubTypes"
You may have multiple Templates defined and available for a given Type (e.g. a 2D and a 3D Template, for a float3). SubTypes allow you to choose which one to use, on a per-GhostField basis. See example below.

Defining Additional Templates
It's possible to register additional types (i.e. types that netcode doesn't already support in its above defaults) so that they can be replicated correctly as GhostFields.

Writing the Template
You must define the Template file correctly. It can be added to any package or folder in the project, but the requirements are:

The file must have a NetCodeSourceGenerator.additionalfile extension (i.e: MyCustomType.NetCodeSourceGenerator.additionalfile).
The first line must contains a#templateid: XXX line. This assign to the template a globally unique user defined id. You will get errors if a) you define a UserDefinedTemplate that has no found Template file b) vice-versa, or c) you make errors when defining the UserDefinedTemplate. Code-Generation errors of the Template may cause compiler errors.
This new template MyCustomNamespace.MyCustomTypeTemplate.NetCodeSourceGenerator.additionalfile needs to be set up similarly to the default types templates. Here is an example copied from the default float template (where the float is quantized and stored in an int field):

#templateid: MyCustomNamespace.MyCustomTypeTemplate
#region __GHOST_IMPORTS__
#endregion
namespace Generated
{
    public struct GhostSnapshotData
    {
        struct Snapshot
        {
            #region __GHOST_FIELD__
            public int __GHOST_FIELD_NAME__;
            #endregion
        }

        public void PredictDelta(uint tick, ref GhostSnapshotData baseline1, ref GhostSnapshotData baseline2)
        {
            var predictor = new GhostDeltaPredictor(tick, this.tick, baseline1.tick, baseline2.tick);
            #region __GHOST_PREDICT__
            snapshot.__GHOST_FIELD_NAME__ = predictor.PredictInt(snapshot.__GHOST_FIELD_NAME__, baseline1.__GHOST_FIELD_NAME__, baseline2.__GHOST_FIELD_NAME__);
            #endregion
        }

        public void Serialize(int networkId, ref GhostSnapshotData baseline, ref DataStreamWriter writer, StreamCompressionModel compressionModel)
        {
            #region __GHOST_WRITE__
            if ((changeMask & (1 << __GHOST_MASK_INDEX__)) != 0)
                writer.WritePackedIntDelta(snapshot.__GHOST_FIELD_NAME__, baseline.__GHOST_FIELD_NAME__, compressionModel);
            #endregion
        }

        public void Deserialize(uint tick, ref GhostSnapshotData baseline, ref DataStreamReader reader,
            StreamCompressionModel compressionModel)
        {
            #region __GHOST_READ__
            if ((changeMask & (1 << __GHOST_MASK_INDEX__)) != 0)
                snapshot.__GHOST_FIELD_NAME__ = reader.ReadPackedIntDelta(baseline.__GHOST_FIELD_NAME__, compressionModel);
            else
                snapshot.__GHOST_FIELD_NAME__ = baseline.__GHOST_FIELD_NAME__;
            #endregion
        }

        public unsafe void CopyToSnapshot(ref Snapshot snapshot, ref IComponentData component)
        {
            if (true)
            {
                #region __GHOST_COPY_TO_SNAPSHOT__
                snapshot.__GHOST_FIELD_NAME__ = (int) math.round(component.__GHOST_FIELD_REFERENCE__ * __GHOST_QUANTIZE_SCALE__);
                #endregion
            }
        }
        public unsafe void CopyFromSnapshot(ref Snapshot snapshot, ref IComponentData component)
        {
            if (true)
            {
                #region __GHOST_COPY_FROM_SNAPSHOT__
                component.__GHOST_FIELD_REFERENCE__ = snapshotBefore.__GHOST_FIELD_NAME__ * __GHOST_DEQUANTIZE_SCALE__;
                #endregion

                #region __GHOST_COPY_FROM_SNAPSHOT_INTERPOLATE_SETUP__
                var __GHOST_FIELD_NAME___Before = snapshotBefore.__GHOST_FIELD_NAME__ * __GHOST_DEQUANTIZE_SCALE__;
                var __GHOST_FIELD_NAME___After = snapshotAfter.__GHOST_FIELD_NAME__ * __GHOST_DEQUANTIZE_SCALE__;
                #endregion
                #region __GHOST_COPY_FROM_SNAPSHOT_INTERPOLATE_DISTSQ__
                var __GHOST_FIELD_NAME___DistSq = math.distancesq(__GHOST_FIELD_NAME___Before, __GHOST_FIELD_NAME___After);
                #endregion
                #region __GHOST_COPY_FROM_SNAPSHOT_INTERPOLATE__
                component.__GHOST_FIELD_REFERENCE__ = math.lerp(__GHOST_FIELD_NAME___Before, __GHOST_FIELD_NAME___After, snapshotInterpolationFactor);
                #endregion
            }
        }
        public unsafe void RestoreFromBackup(ref IComponentData component, in IComponentData backup)
        {
            #region __GHOST_RESTORE_FROM_BACKUP__
            component.__GHOST_FIELD_REFERENCE__ = backup.__GHOST_FIELD_REFERENCE__;
            #endregion
        }
        public void CalculateChangeMask(ref Snapshot snapshot, ref Snapshot baseline, uint changeMask)
        {
            #region __GHOST_CALCULATE_CHANGE_MASK_ZERO__
            changeMask = (snapshot.__GHOST_FIELD_NAME__ != baseline.__GHOST_FIELD_NAME__) ? 1u : 0;
            #endregion
            #region __GHOST_CALCULATE_CHANGE_MASK__
            changeMask |= (snapshot.__GHOST_FIELD_NAME__ != baseline.__GHOST_FIELD_NAME__) ? (1u<<__GHOST_MASK_INDEX__) : 0;
            #endregion
        }
        #if UNITY_EDITOR || NETCODE_DEBUG
        private static void ReportPredictionErrors(ref IComponentData component, in IComponentData backup, ref UnsafeList<float> errors, ref int errorIndex)
        {
            #region __GHOST_REPORT_PREDICTION_ERROR__
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.__GHOST_FIELD_REFERENCE__ - backup.__GHOST_FIELD_REFERENCE__));
            ++errorIndex;
            #endregion
        }
        private static int GetPredictionErrorNames(ref FixedString512Bytes names, ref int nameCount)
        {
            #region __GHOST_GET_PREDICTION_ERROR_NAME__
            if (nameCount != 0)
                names.Append(new FixedString32Bytes(","));
            names.Append(new FixedString64Bytes("__GHOST_FIELD_REFERENCE__"));
            ++nameCount;
            #endregion
        }
        #endif
    }
}
A good way to assign this "#templateid" is to use something like CustomNamespace.CustomTemplateFileName. All the default Netcode package template uses an internal id (not present in the template) with the following format: NetCode.GhostSnapshotValueXXX.cs.

NOTE
The default types uses a slightly different approach at the moment, being embedded in the generator dlls. The template contains a set of c-sharp like regions, #region __GHOST_XXX__, that are processed by code gen, and uses them to extract the code inside the region to create the serializer. The template uses the __GHOST_XXX__ as reserved keyword, and are substituted at generation time with the corresponding variable names and/or values.

For more information about the template format you can check the documentation present in the SourceGenerator/Documentation folder, or reference to other template files (see Editor/Templates/DefaultTypes).

Registering your new Template with NetCode
Templates are added to the project by implementing a partial class, UserDefinedTemplates, and then injecting it into the Unity.Netcode package by using an AssemblyDefinitionReference. The partial implementation must define the method RegisterTemplates, and add a new TypeRegistry entry (or entries).

The class must also exist inside the Unity.NetCode.Generators namespace.

namespace Unity.NetCode.Generators
{
    public static partial class UserDefinedTemplates
    {
        static partial void RegisterTemplates(System.Collections.Generic.List<TypeRegistryEntry> templates, string defaultRootPath)
        {
            templates.AddRange(new[]{
                new TypeRegistryEntry
                {
                    Type = "MyCustomNamespace.MyCustomType",
                    Quantized = true,
                    Smoothing = SmoothingAction.InterpolateAndExtrapolate,
                    SupportCommand = false,
                    Composite = false,
                    Template = "Assets/Samples/NetCodeGen/Templates/MyCustomNamespace.MyCustomTypeTemplate.NetCodeSourceGenerator.additionalfile",
                    TemplateOverride = "",
                },
            });
        }
    }
}
![NOTE]: This above example only registers MyCustomType when the GhostField is defined as follows [GhostField(Quantization=100, Smoothing=SmoothingAction.InterpolateAndExtrapolate, Composite=false)]. You must register all exact combinations you wish to support (and register them exactly as used).

Additional Template Definition Rules
When Quantized is set to true, the __GHOST_QUANTIZE_SCALE__ variable must be present in the template. Also, the quantization scale must be specified when using the type in a GhostField.

Smoothing is also important, as it changes how serialization is done in the CopyFromSnapshot function. In particular:

When smoothing is set to Clamp, only the __GHOST_COPY_FROM_SNAPSHOT__ is required.
When smoothing is set to Interpolate or InterpolateAndExtrapolate, the regions __GHOST_COPY_FROM_SNAPSHOT__, __GHOST_COPY_FROM_SNAPSHOT_INTERPOLATE__, GHOST_COPY_FROM_SNAPSHOT_INTERPOLATE_SETUP, __GHOST_COPY_FROM_SNAPSHOT_INTERPOLATE_DISTSQ__ and GHOST_COPY_FROM_SNAPSHOT_INTERPOLATE_CLAMP_MAX must be present and filled in.
The SupportCommand denotes if the type can be used inside Commands and/or Rpc.

The Template value is mandatory, and must point to the #templateid defined in the target Template file.

The TemplateOverride is optional (can be null or empty). TemplateOverride is used when you want to re-use an existing template, but only override a specific section of it. This works well when using Composite types, as you'll point Template to the basic type (like the float template), and then point to the TemplateOverride only for the sections which need to be customized. For example; float2 only defines CopyFromSnapshot, ReportPredictionErrors and GetPredictionErrorNames, the rest uses the basic float template as a composite of the 2 values float2 contains. The assigned value must be the #templateid of the "base" template, as declared inside the other template file.

The Composite flag should be true when declaring templates for 'container-like' types (i.e. types that contain multiple fields of the same type (like float3, float4 etc)). When this is set, the Template and TemplateOverride are applied to the field types, and not to containing type.

If you need your template to define additional fields in the snapshot (for example: to map correctly on the server), you must define __GHOST_CALCULATE_CHANGE_MASK_NO_COMMAND__ and __GHOST_CALCULATE_CHANGE_MASK_ZERO_NO_COMMAND__ in the changemask calculation method, as commands point to the type directly (but components have snapshots that can store additional data). These changemasks can then be correctly found for any/all additional field(s). See the GhostSnapshotValueEntity Template for an example.

All sections must be filled in.

![NOTE]: When making changes to the templates you need to use the Multiplayer->Force Code Generation menu to force a new code compilation (which will then use the updated templates).

Defining SubType Templates
As mentioned, Subtypes are a way to define multiple templates for a given type. You use them by specifying them in the GhostField attribute.

using Unity.NetCode;

public struct MyComponent : Unity.Entities.IComponentData
{
    [GhostField(SubType=GhostFieldSubType.MySubType)] // <- This field uses the SubType `MySubType`.
    public float value;
    [GhostField] // <- This filed uses the default serializer Template for unquantized floats.
    public float value;
}
SubTypes are added to projects by implementing a partial class, GhostFieldSubTypes, and injecting it into the Unity.Netcode package by using an AssemblyDefinitionReference. The implementation should just need to add new constant string literals to that class (at your own discretion) and they will be available to all your packages which already reference the Unity.Netcode assembly.

namespace Unity.NetCode
{
    static public partial class GhostFieldSubType
    {
        public const int MySubType = 1;
    }
}
Templates for the SubTypes are handled identically to other UserDefinedTemplates, but need to set the SubType field index. Therefore, see the above tutorial to define a Template, and note the only difference is: SubType = GhostFieldSubType.MySubType,.

namespace Unity.NetCode.Generators
{
    public static partial class UserDefinedTemplates
    {
        static partial void RegisterTemplates(System.Collections.Generic.List<TypeRegistryEntry> templates, string defaultRootPath)
        {
            templates.AddRange(new[]{
                new TypeRegistryEntry
                {
                    Type = "System.Single",
                    SubType = GhostFieldSubType.MySubType,
                    ...
                },
            });
        }
    }
}
As when using any template registration like this, you need to be careful to specify the correct parameters when defining the GhostField to exactly match it. The important properties are SubType (of course), in addition to Quantized and Smoothing, as these can affect how the serializer code is generated from the template.

IMPORTANT: The Composite parameter should always be false with subtypes, as it is assumed the Template given is the one in use for the whole type.
